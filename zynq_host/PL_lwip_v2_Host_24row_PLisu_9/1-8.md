
你現在是image process designer，Host端需以python做稀疏光流演算法
1- 依序讀出f'SD_image_{page}.bmp'，格式為720*480pixels, pages = 1~4
2- 分析OpticalFlow algorithm子模組流程:{前後張相減->Erosion->Harris->ORB->matching}
3- 另寫OpticalFlow algorithm子模組在其他的def;
4- 依序讓前後張經過上述子模組，得到OpticalFlow圖(720*480 pixels)

1- 將各模組寫得更詳細
2- 寫出完整的imgs_OpticalFlow.py
3- 檢查python的語法、import
    
1- 將各模組寫得再更詳細
2- page = 5，則連續撥放稀疏光流結果(720*480 pixel)

1- 將各模組、sparse_optical_flow()寫得再更詳細
2- 寫出完整的imgs_OpticalFlow.py
3- 請完成:
"""
    # 可以使用OpenCV的VideoWriter來將處理結果保存為視頻mp4
    # 連續撥放處理結果（待完成）
"""

1- 請對draw_optical_flow線條改畫"綠色"，不做cv2.circle
2- 保存完視頻就自動撥放處理結果
3- 請您寫出更完整的imgs_OpticalFlow.py

1- 將當前張的page, x, y pts print()
2- 另存page, x, y座標到自訂一的CSV檔案
3- 請您寫出更完整的imgs_OpticalFlow.py

1- 將page的range改成1開始，把page的range上限另外宣告
2- 若"for page in range(2, max_page + 1):"之前加上if (page上限值mod 10 = 0) #代表新的10張畫面進了，則再刷新CSV檔案、video_output.write(output_img)  # 寫入視頻
3- 若保存完視頻等於60張就自動撥放
4- 請您寫出更完整的imgs_OpticalFlow.py





你現在是Soc designer，改良下方.py:
"""
last_lwip_cnt = 0  # 保存上一次的 lwip_cnt 值

while True:
    try:
        data = sock.recv(65535)
        lwip_cnt += 1

        # 检查 lwip_cnt 是否有变动
        if lwip_cnt != last_lwip_cnt:
            last_lwip_cnt = lwip_cnt  # 更新 last_lwip_cnt

            for pac_index in range(24):
                # your existing code inside this loop

    except:
        continue

    # rest of your code

"""
1- 若lwip_cnt有變動才進"for pac_index in range(24): "
